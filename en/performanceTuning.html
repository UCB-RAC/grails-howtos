<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" type="text/css" href="../css/main.css" />
        <link rel="shortcut icon" href="../img/favicon.ico" />
        <script type="text/javascript" src="../js/jquery-1.7.1.min.js"></script>
        <!--[if !IE]>-->
        <style type="text/css">
        body {
            font-size:16px;
        }
        </style>
        <!--<[endif]-->
        <title>How To: Tune the performance of Grails apps</title>
    </head>
    <body>
        <div id="header-container">
            <div id="header">
                <a href="http://grails.org"><img src="../img/grails.png" alt="GRAILS HOW-TOs" /></a>
                <a id="all_links_toggler">Browse all How-Tos</a>
                <div id="all_links">
                    
                    <a href="migrateToTheNewCentralRepository.html">How to migrate to the new Grails Central repository</a>
                    
                    <a href="upgradeToGrails2.html">Upgrade to Grails 2</a>
                    
                    <a href="contributeToTheseGuides.html">Contribute to these guides</a>
                    
                    <a href="performanceTuning.html">Tune the performance of Grails apps</a>
                    
                    <a href="pluginDevelopmentBestPractices.html">Grails Plugin Development Best Practices</a>
                    
                    <a href="manageDatabases.html">Manage databases</a>
                    
                </div>
            </div>
        </div>
        <div id="main-container">
            <div id="toc">
                <h3>Sections</h3>
                <ol>
                
                    <li><a href="#s1">Increase number of concurrent users</a></li>
                
                    <li><a href="#s2">Improve throughput</a></li>
                
                    <li><a href="#s3">Benchmark happy</a></li>
                
                </ol>
            </div>

            <div id="content"><h1>Tune the performance of Grails apps</h1><p class="paragraph"/>For many developers, a standard Grails application works plenty fast enough, particularly with judicious use of caching. Yet there is almost always a trade-off between convenience and flat out speed. So if you need to increase the number of concurrent users that can be handled or increase the number of requests per second that are processed, read on.<p class="paragraph"/>But! Before you do, please remember that every application is different. Sometimes an application is slow simply because it's executing way more queries than it needs to. For that reason, you should always profile your application to find out what's happening. The following suggestions only really apply if you discover that it's not your application code that's the problem.<p class="paragraph"/><h2 id="s1">Increase number of concurrent users</h2><p class="paragraph"/>If you know that you're going to have quite a few active users at any one time (hundreds -&#62; thousands), then there are some simple steps that you can take to ensure that they can all happily use your app at the same time.<p class="paragraph"/><h3>Disable Open Session In View filter</h3><p class="paragraph"/>A standard Grails application with the Hibernate plugin installed has a special request interceptor enabled that opens a Hibernate session for every request and keeps it open until the view is rendered. This is convenient for the developer but acts as a drag on the number of concurrent requests that can be processed as each Hibernate session fetches a database connection.<p class="paragraph"/>The simplest way to disable the filter is to remove the Hibernate plugin. Of course, this isn't ideal if you actually use GORM/Hibernate! The alternative is to write a no-op interceptor and configure it as the <code>openSessionInViewInterceptor</code> bean in <code>resources.groovy</code>. TODO Add code for no-op interceptor<p class="paragraph"/>Be warned that if you disable the interceptor, the standard Grails scaffolding will break and you will also need to ensure that you manage the sessions yourself. Fortunately, if you perform all database access through transactional services, you're already covered. Still, even then you will need to make sure that any collections you access from your views are eagerly loaded.<p class="paragraph"/><h3>Flash and sessions</h3><p class="paragraph"/>As soon as you use flash scope, Grails creates an HTTP session. The lifetime of that session depends on what is configured in web.xml, but by default it's 30 mins. As you can see, if lots of people hit flash-enabled pages at the same time (or within a half-hour window), your application will end up with a large number of active sessions.<p class="paragraph"/>One 'fix' is to reduce the session timeout to something much lower. You can do this by running<p class="paragraph"/><div class="code"><pre>grails install&#45;templates</pre></div><p class="paragraph"/>and then editing <code>src/templates/war/web.xml</code>:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;session&#45;config&#62;</span>
    <span class="xml&#45;comment">&#60;!&#45;&#45; 1 minute timeout for benchmarking &#45;&#45;&#62;</span>
    <span class="xml&#45;tag">&#60;session&#45;timeout&#62;</span>1<span class="xml&#45;tag">&#60;/session&#45;timeout&#62;</span> 
<span class="xml&#45;tag">&#60;/session&#45;config&#62;</span></pre></div><p class="paragraph"/>This isn't ideal though if you want users to log in and not have to log in every minute! In such cases, you should probably avoid using flash in pages that don't require a logged in user.<p class="paragraph"/><h3>XML and JSON rendering</h3><p class="paragraph"/>The markup builder syntax for generating XML responses is very convenient. But it's not terribly fast. The same goes for JSON. If you discover that the rendering time is proving a bottleneck, first try the <code>as XML</code> and <code>as JSON</code> feature. If you still need improvements, consider using alternative libraries such as Jackson for JSON.<p class="paragraph"/><h2 id="s2">Improve throughput</h2><p class="paragraph"/>Sometimes the only metric that counts is the number of requests per second. This section details some of the steps you can take to crank up those numbers.<p class="paragraph"/><h3>Disable Hibernate caches</h3><p class="paragraph"/>The Hibernate's legacy 2nd-level cache interface (cache provider api) is a source of monitor (thread) blocking. So for high throughput you should disable the 2nd-level cache completely by removing<p class="paragraph"/><div class="code"><pre>hibernate &#123;
    cache.use_second_level_cache = <span class="java&#45;keyword">true</span>
    cache.use_query_cache = <span class="java&#45;keyword">true</span>
    cache.provider_class = 'net.sf.ehcache.hibernate.EhCacheProvider'
&#125;</pre></div><p class="paragraph"/>from <code>DataSource.groovy</code>. Unless...you are using Grails 2.x+ with Ehcache. This is because those versions of Grails will automatically use a new Hibernate API that  <em class="italic">doesn't</em>  block. But this only happens with Ehcache.<p class="paragraph"/>The Hibernate query cache is problematic on it's own. For a start, it doesn't work well with tables whose data changes frequently. In fact, queries can be  <em class="italic">slower</em>  if you use the cache in these circumstances. You should only really use the query cache for reference datathat doesn't change often. In addition, there is a <a href="null/ref/Httpshibernateonjiracombrowse HHH 5927/Hibernate issue.html" class="https://hibernate.onjira.com/browse/HHH-5927">Hibernate issue</a> for versions prior to 4.1.1 that results in threads blocking.<p class="paragraph"/>Ultimately, you are probably better off caching at the service and view layer via the <a href="http://grails.org/plugin/cache" target="blank">Cache plugin</a>.<p class="paragraph"/><h3>Command objects</h3><p class="paragraph"/>Prior to Grails 2, command object binding could prove a significant bottleneck to throughput. If that's the case for your application, then consider changing your action code from something like<p class="paragraph"/><div class="code"><pre>def save = &#123; UserCommand userCommand &#45;&#62;
    &#8230;
&#125;</pre></div><p class="paragraph"/>to<p class="paragraph"/><div class="code"><pre>def save = &#123; &#45;&#62;
    UserCommand userCommand = <span class="java&#45;keyword">new</span> UserCommand()
    bindData(userCommand, params)
    &#8230;
&#125;</pre></div><p class="paragraph"/>Just to clarify again, this is not a problem in Grails 2 and above.<p class="paragraph"/><h2 id="s3">Benchmark happy</h2><p class="paragraph"/>People like benchmarks, and that's fair enough because they're often the only source of information for how well something will perform. But they often  <em class="italic">don't</em>  reflect real world usage. Still, if you are doing some benchmarks, here are some tips to get the best numbers (and of course these can help in production apps too!).<p class="paragraph"/><h3>Warm up the JVM</h3><p class="paragraph"/>In benchmarking Grails you usually have to first do about 20000 requests and give the JVM a breath for about 10 seconds after that, possibly because the JVM delays background compilation when CPU usage is high and it does JIT compilation during this sleep time.  After this, the throughput performance is usually about 5x better than in the beginning.<p class="paragraph"/><h3>JVM settings</h3><p class="paragraph"/>Have you set Permgen size to something reasonable (for example: -XX:PermSize=128M -XX:MaxPermSize=256M)? The <code>run-app</code> and <code>run-war</code> commands do this automatically, but make sure your production servlet container does the same.<p class="paragraph"/>Example settings for Tomcat (in $CATALINA_HOME/bin/setenv.sh):<p class="paragraph"/><div class="code"><pre>CATALINA_OPTS=<span class="java&#45;quote">"&#45;server &#45;noverify &#45;Xshare:off &#45;Xms512M &#45;Xmx512M &#45;XX:MaxPermSize=256M &#45;XX:PermSize=128M &#45;XX:+UseParallelGC"</span>
CATALINA_OPTS=<span class="java&#45;quote">"$&#123;CATALINA_OPTS&#125; &#45;Dgrails.env=production"</span>
CATALINA_OPTS=<span class="java&#45;quote">"$&#123;CATALINA_OPTS&#125; &#45;Djava.net.preferIPv4Stack=<span class="java&#45;keyword">true</span> &#45;XX:+EliminateLocks &#45;XX:+UseBiasedLocking"</span>
&#35; optional setting: MaxJavaStackTraceDepth, it reduces performance overhead of <span class="java&#45;object">long</span> exception stacktraces by limiting their size to 100 stacktrace elements
&#35; You should eliminate all exceptions (even catched) to get good Grails performance
&#35; always use some JVM profiler (<span class="java&#45;keyword">for</span> example Yourkit YJP) to see <span class="java&#45;keyword">if</span> any exceptions are created during normal program flow
&#35; Grails and Groovy create some exceptions in initializations but after a few requests, no <span class="java&#45;keyword">new</span> exceptions should be created.
CATALINA_OPTS=<span class="java&#45;quote">"$&#123;CATALINA_OPTS&#125; &#45;XX:MaxJavaStackTraceDepth=100"</span></pre></div><p class="paragraph"/>The JVM version can also have an impact, so be sure your JVM is up to date.<p class="paragraph"/><h3>OS</h3><p class="paragraph"/>Have you checked if your OS starts swapping? (Monitoring in Linux: "vmstat 1", make sure "swap si / so" are 0 during the benchmark).
For Linux, use should usually tune swappiness for running a JVM. In /etc/sysctl.conf:
<div class="code"><pre>vm.swappiness=5
(changing temporarily/immediately: <span class="java&#45;quote">"echo 5 | sudo tee /proc/sys/vm/swappiness"</span>)
Checking current value: cat /proc/sys/vm/swappiness</pre></div><p class="paragraph"/>vm.swappiness defaults to 60 on many distros and that means that the OS starts swapping after 60% of memory is used. Since the JVM allocates a lot of memory, it will usually cause some swapping if you don't tune swappiness.<p class="paragraph"/>You might also have to tune the Linux OS TCP/IP settings if "netstat -an" still shows a lot of hanging connections after adding the id-parameter to grails-rest calls.
</div>
        </div>
        <script type="text/javascript" src="../js/application.js"></script>
    </body>
</html>
